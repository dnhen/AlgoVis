{"version":3,"sources":["components/Logo.svg","components/Header.js","algorithms/dijkstras.js","algorithms/astar.js","Helpers.js","App.js","reportWebVitals.js","index.js"],"names":["Header","onClick","info","className","src","logo","alt","id","value","copyGrid","grid","output","forEach","row","rowId","newRow","cell","cellId","push","col","startCell","endCell","wall","visited","distance","prevCell","highlight","placeStartCell","placeEndCell","placeWalls","visualising","placeStartButtonId","placeEndButtonId","placeWallsButtonId","visualiseButtonId","displayTimeout","handleNavClick","buttonId","document","getElementById","classList","remove","add","algoSelected","sortByDistance","unvisitedCells","sort","cellA","cellB","updateNeighbours","currCell","currDist","length","gridArray","foundEnd","lastCell","x","y","getAllCells","newGrid","shift","Infinity","finalPath","dijkstras","alert","setGrid","open","closed","getNeighbours","i","some","val","valId","fCost","Math","floor","sqrt","pow","astar","grids","paths","setTimeout","path","setStartCell","slice","ROWS","window","innerHeight","COLS","innerWidth","App","useState","setEndCell","walls","setWalls","useEffect","rows","cols","start","end","updateGrid","map","index","findIndex","newWalls","splice","concat","handleClick","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.95bb65a7.chunk.js","sourcesContent":["export default __webpack_public_path__ + \"static/media/Logo.756a4d9a.svg\";","import logo from './Logo.svg';\n\nconst Header = ( { onClick, info } ) => {\n  return (\n    <header className=\"header\">\n      <div className=\"header-container\">\n        <img src={logo} className=\"logo\" alt=\"Logo\" />\n        <p className=\"header-text\">ALGOVIS</p>\n        <p className=\"navOption\" id=\"placeStartButton\" onClick={() => onClick(\"placeStartButton\")}>Place Starting Node</p>\n        <p className=\"navOption\" id=\"placeEndButton\" onClick={() => onClick(\"placeEndButton\")}>Place Ending Node</p>\n        <p className=\"navOption\" id=\"placeWallsButton\" onClick={() => onClick(\"placeWallsButton\")}>Place Walls</p>\n        <div className=\"navOption\">\n          <select id=\"algoSelectBox\">\n            <option className=\"dropped\" value=\"dijkstras\">Dijkstra's</option>\n            <option className=\"dropped\" value=\"astar\">A*</option>\n          </select>\n        </div>\n        <p className=\"navOption\" id=\"visualiseButton\" onClick={() => onClick(\"visualiseButton\", info)}>Visualise!</p>\n        <p className=\"navOption\" id=\"resetButton\" onClick={() => onClick(\"resetButton\", info)}>Reset</p>\n      </div>\n    </header>\n  );\n}\n\nexport default Header;","// Function to return in order the grid as cells are visited, and the final path of cells\n//\n// @param grid            Arr: the grid array\n// @param setGrid         Func: the function to set the grid\n// @param startCell       Arr: the coords of the starting cell\n//\n// @return                Arr: the final array of all grid variations (for visited cells) and final path in format [grids, paths]\nexport function dijkstras( { grid, startCell } ){\n  // Function -> Gets the coords [x, y] of each cell in the grid (to track min distance)\n  function getAllCells(grid){\n    let output = [];\n\n    for(let x = 0; x < grid.length; x++){\n      for(let y = 0; y < grid[x].length; y++){\n        output.push([x, y]);\n      }\n    }\n\n    return output;\n  }\n\n  // Function to sort cells by distance\n  function sortByDistance(unvisitedCells, grid){\n    return unvisitedCells.sort((cellA, cellB) => grid[cellA[0]][cellA[1]].distance - grid[cellB[0]][cellB[1]].distance);\n  }\n\n  // Function to update the distances of each neighbour by 1\n  function updateNeighbours(currCell, grid){\n    let row = currCell[0];\n    let col = currCell[1];\n    const currDist = grid[row][col].distance\n\n    // Get top, bottom, left, and right -> update dist and set prev node\n    if(row-1 >= 0 && !grid[row-1][col].visited){\n      grid[row-1][col].distance = currDist + 1;\n      grid[row-1][col].prevCell = currCell;\n    }\n    if(row+1 < grid.length && !grid[row+1][col].visited){\n      grid[row+1][col].distance = currDist + 1;\n      grid[row+1][col].prevCell = currCell;\n    }\n    if(col-1 >= 0 && !grid[row][col-1].visited){\n      grid[row][col-1].distance = currDist + 1;\n      grid[row][col-1].prevCell = currCell;\n    }\n    if(col+1 < grid[0].length && !grid[row][col+1].visited){\n      grid[row][col+1].distance = currDist + 1;\n      grid[row][col+1].prevCell = currCell;\n    }\n\n    return grid;\n  }\n\n  let gridArray = [];\n  let foundEnd = false;\n  let lastCell = null;\n  let unvisitedCells = getAllCells(grid);\n  grid[startCell[0]][startCell[1]].distance = 0;\n  let newGrid = copyGrid(grid);\n\n  while(unvisitedCells.length > 0 && !foundEnd){ // Continue looping till we visited all nodes or we reached end node\n    //let newGrid = grid.slice();\n    unvisitedCells = sortByDistance(unvisitedCells, newGrid);\n    let currCell = unvisitedCells.shift(); // Get first cell off the array (least distance)\n    lastCell = currCell; // Set the last cell to be the current cell (if we reach end, so we can back-track)\n\n    if(newGrid[currCell[0]][currCell[1]].wall) continue; // Ignore if wall\n    if(newGrid[currCell[0]][currCell[1]].distance === Infinity) foundEnd = true; // We are stuck in loop, stop the loop.\n    if(newGrid[currCell[0]][currCell[1]].endCell) foundEnd = true; // We found the end cell -> end\n\n    newGrid[currCell[0]][currCell[1]].visited = true; // Update current node to be visited\n    newGrid[currCell[0]][currCell[1]].distance += 1; // Update current node distance to be +1\n    newGrid = updateNeighbours(currCell, newGrid); // Update all the neighbours to have a distacne of +1\n    \n    //setGrid(newGrid);\n    gridArray.push(newGrid);\n    newGrid = copyGrid(newGrid);\n  }\n\n  // Highlight the path\n  let finalPath = [];\n  let currCell = lastCell;\n  newGrid = copyGrid(newGrid);\n\n  while(currCell !== null){\n\n    newGrid[currCell[0]][currCell[1]].highlight = true; // Highlight the current cell\n    currCell = newGrid[currCell[0]][currCell[1]].prevCell; // Get the previous cell\n\n    //setGrid(newGrid);\n    finalPath.push(newGrid);\n    newGrid = copyGrid(newGrid);\n  }\n  \n  return [gridArray, finalPath];\n}\n\nfunction copyGrid(grid){\n  let output = [];\n\n  grid.forEach((row, rowId) => {\n    let newRow = [];\n    row.forEach((cell, cellId) => {\n      newRow.push({\n        row: cell.row,\n        col: cell.col,\n        startCell: cell.startCell,\n        endCell: cell.endCell,\n        wall: cell.wall, // Loop through the walls array and set true value if the row and col is in the walls array, then check if true was found\n        visited: cell.visited,\n        distance: cell.distance,\n        prevCell: cell.prevCell,\n        highlight: cell.highlight\n      });\n    });\n    output.push(newRow);\n  })\n\n  return output;\n}","// Function to return in order the grid as cells are visited, and the final path of cells\n//\n// @param grid            Arr: the grid array\n// @param setGrid         Func: the function to set the grid\n// @param startCell       Arr: the coords of the starting cell\n//\n// @return                Arr: the final array of all grid variations (for visited cells) and final path in format [grids, paths]\nexport function astar( { grid, setGrid, startCell, endCell } ){\n  // Function to sort cells by distance\n  function sortByDistance(unvisitedCells, grid){\n    return unvisitedCells.sort((cellA, cellB) => grid[cellA[0]][cellA[1]].distance - grid[cellB[0]][cellB[1]].distance);\n  }\n\n  // Function to return the neighbours coords (top bottom left right), that are not walls\n  function getNeighbours(currCell, grid){\n    let row = currCell[0];\n    let col = currCell[1];\n    let output = [];\n\n    // Get top, bottom, left, and right -> update dist and set prev node\n    if(row-1 >= 0 && !grid[row-1][col].wall){\n      output.push([row-1, col]);\n    }\n    if(row+1 < grid.length && !grid[row+1][col].wall){\n      output.push([row+1, col]);\n    }\n    if(col-1 >= 0 && !grid[row][col-1].wall){\n      output.push([row, col-1]);\n    }\n    if(col+1 < grid[0].length  && !grid[row][col+1].wall){\n      output.push([row, col+1]);\n    }\n\n    return output;\n  }\n  /*\n  OPEN // the set of nodes to be avaluated\n  CLOSED // the ser of nodes already evaluated\n  add the start node to OPEN\n\n  loop\n    current = node in OPEN with the lowest f_cost\n    remove current from OPEN\n    add current to CLOSED\n    \n    if current is the target node\n      return // path has been found\n    \n    foreach neighbour of the current node\n      if neighbour is not traversable or neighbour is in CLOSED\n        skip to the next neighbour\n\n      if new path to neighbour is shorter OR neighbour is not in OPEN\n        set f_cost of neighbour\n        set parent of neighbour to current\n        if neighbour is not in OPEN\n          add neighbour to OPEN\n  */\n\n  let gridArray = [];\n  let newGrid = copyGrid(grid);\n  let lastCell = null;\n  let open = [];\n  let closed = [];\n  let foundEnd = false;\n  open.push(startCell);\n\n  while(!foundEnd && open.length > 0){\n\n    open = sortByDistance(open, newGrid); // Sort by the fCost (stored as distance)\n    let currCell = open.shift(); // Get the cell with smallest f cost\n    closed.push(currCell); // Add the current cell to closed array\n    lastCell = currCell;\n\n    if(newGrid[currCell[0]][currCell[1]].endCell){ // We found the end -> path has been found\n      foundEnd = true;\n    }\n\n    let neighbours = getNeighbours(currCell, newGrid);\n\n    neighbours.forEach((cell, i) => {\n      if(!closed.some((val, valId) => val[0] === cell[0] && val[1] === cell[1])){ // If the cell is NOT in closed\n        let gCost = Math.floor(Math.sqrt(Math.pow(cell[0]-startCell[0], 2) + Math.pow(cell[1]-startCell[1], 2)));\n        let hCost = Math.floor(Math.sqrt(Math.pow(cell[0]-endCell[0], 2) + Math.pow(cell[1]-endCell[1], 2)));\n        let fCost = gCost + hCost;\n\n        if(fCost < newGrid[cell[0]][cell[1]].distance || !open.some((val, valId) => val[0] === cell[0] && val[1] === cell[1])){ // If new path is shorter or neighbour not in OPEN\n          newGrid[cell[0]][cell[1]].distance = fCost;\n          newGrid[cell[0]][cell[1]].visited = true;\n          newGrid[cell[0]][cell[1]].prevCell = currCell;\n          if(!open.some((val, valId) => val[0] === cell[0] && val[1] === cell[1])){ // if neighbour not in OPEN\n            open.push(cell);\n          }\n        }\n      }\n    });\n    \n    gridArray.push(newGrid);\n    newGrid = copyGrid(newGrid);\n  }\n\n  // Highlight the path\n  let finalPath = [];\n  let currCell = lastCell;\n  newGrid = copyGrid(newGrid);\n\n  while(currCell !== null){\n\n    newGrid[currCell[0]][currCell[1]].highlight = true; // Highlight the current cell\n    currCell = newGrid[currCell[0]][currCell[1]].prevCell; // Get the previous cell\n\n    //setGrid(newGrid);\n    finalPath.push(newGrid);\n    newGrid = copyGrid(newGrid);\n  }\n\n  return [gridArray, finalPath];\n}\n\nfunction copyGrid(grid){\n  let output = [];\n\n  grid.forEach((row, rowId) => {\n    let newRow = [];\n    row.forEach((cell, cellId) => {\n      newRow.push({\n        row: cell.row,\n        col: cell.col,\n        startCell: cell.startCell,\n        endCell: cell.endCell,\n        wall: cell.wall, // Loop through the walls array and set true value if the row and col is in the walls array, then check if true was found\n        visited: cell.visited,\n        distance: cell.distance,\n        prevCell: cell.prevCell,\n        highlight: cell.highlight\n      });\n    });\n    output.push(newRow);\n  })\n\n  return output;\n}","import { dijkstras } from './algorithms/dijkstras.js';\nimport { astar } from './algorithms/astar.js';\n\nlet placeStartCell = false;\nlet placeEndCell = false;\nlet placeWalls = false;\nlet visualising = false;\n\nconst placeStartButtonId = \"placeStartButton\";\nconst placeEndButtonId = \"placeEndButton\";\nconst placeWallsButtonId = \"placeWallsButton\";\nconst visualiseButtonId = \"visualiseButton\";\nconst resetButtonId = \"resetButton\";\n\nconst displayTimeout = 10;\n\n// Updates the grid, rendering each cell and setting the start and end nodes their correct colours\n//\n// @param rows            Int: number of rows in the grid\n// @param cols            Int: number of columns in the grid\n// @param start           Arr: start cell array in format [row, column] of the current start val\n// @param end             Arr: end cell array in format [row, column] of the current end val\n// @param walls           Arr: wall array in format [[row, column], [row, column], etc...] of where the walls are\n//\n// @return null\nexport function updateGrid(rows, cols, start, end, walls){\n  let newGrid = [];\n\n  // Loop through all rows, and cols and set the grid to be them\n  for(let row = 0; row < rows; row++){\n    let newRow = [];\n    for(let col = 0; col < cols; col++){\n      newRow.push({\n        row: {row},\n        col: {col},\n        startCell: row === start[0] && col === start[1],\n        endCell: row === end[0] && col === end[1],\n        wall: walls.some((val, valId) => val[0] === row && val[1] === col), // Loop through the walls array and set true value if the row and col is in the walls array, then check if true was found\n        visited: false,\n        distance: Infinity,\n        prevCell: null,\n        highlight: false\n      });\n    }\n    newGrid.push(newRow);\n  }\n  \n  return newGrid;\n}\n\n// Gets called every time the user clicks on a cell\n//\n// @param row             Int: the clicked row number\n// @param col             Int: the clicked column number\n// @param setStartCell    Func: the function to set the start cell state\n// @param setEndCell      Func: the function to set the end cell state\n// @param wallObj         Obj: walls object which contains {walls, setWalls} that is the useState object\n//\n// @return null\nexport function handleClick(row, col, grid, setStartCell, setEndCell, {walls, setWalls}){\n  if(placeStartCell && !grid[row][col].wall){ // If placeStartCell is active, set the new start cell and reset the navbar to be not highlighted\n    setStartCell([row, col]);\n    placeStartCell = false;\n    document.getElementById(placeStartButtonId).classList.remove(\"active\");\n  } else if(placeEndCell && !grid[row][col].wall){ // If placeEndCell is active, set the new end cell and reset the navbar to be not highlighted\n    setEndCell([row, col]);\n    placeEndCell = false;\n    document.getElementById(placeEndButtonId).classList.remove(\"active\");\n   } else if(placeWalls){ // If placeWalls is active, place walls where the user clicks\n    if(!walls.some((val, valId) => val[0] === row && val[1] === col)){ // Not in array -> add to walls\n      if(!grid[row][col].startCell && !grid[row][col].endCell){ // We arent placing walls on end and start cell\n        setWalls(walls.concat([[row, col]]));\n      }\n    } else { // Remove the wall the user clicked\n      const index = walls.findIndex((val, valId) => val[0] === row && val[1] === col);\n      let newWalls = walls.slice();\n      newWalls.splice(index, 1);\n      setWalls(newWalls);\n    }\n   }\n}\n\n// Gets called every time the user clicks on an option in the navbar\n//\n// @param buttonId        Str: the ID of the button that was pressed\n// @param info            Obj: grid, setGrid, startCell, endCell\n//\n// @return null\nexport function handleNavClick(buttonId, info){\n  if(!placeStartCell && !placeEndCell && !placeWalls && !visualising){ // None of the menu buttons are toggled on\n    // Set clicked button to be active\n    document.getElementById(buttonId).classList.add(\"active\");\n\n    if(buttonId === placeStartButtonId){ // User clicked place start node button\n      placeStartCell = true;\n    } else if(buttonId === placeEndButtonId){ // User clicked place end node button\n      placeEndCell = true;\n    } else if(buttonId === placeWallsButtonId){\n      placeWalls = true;\n    } else if(buttonId === visualiseButtonId){\n      visualising = true;\n\n      const algoSelected = document.getElementById(\"algoSelectBox\").value;\n      let output = null;\n\n      if(algoSelected === \"dijkstras\"){\n        output = dijkstras(info);\n      } else if(algoSelected === \"astar\"){\n        output = astar(info);\n      } else { // Error in algorithm selection -> display error.\n        alert(\"Please select a valid algorithm!\");\n        document.getElementById(visualiseButtonId).classList.remove(\"active\");\n        visualising = false;\n        return;\n      }\n\n      visualiseAlgorithm(output[0], output[1], info.setGrid);\n\n      // Run after all displaying is complete\n      setTimeout(() => {\n        document.getElementById(visualiseButtonId).classList.remove(\"active\");\n        visualising = false;\n      }, displayTimeout * output[0].length + (displayTimeout * 2) * output[1].length);\n    } else if(buttonId === resetButtonId){ // Reset the grid\n      info.setStartCell(info.startCell.slice());\n      document.getElementById(buttonId).classList.remove(\"active\");\n    }\n  } else if(buttonId === placeWallsButtonId && placeWalls){ // Place walls is toggled on (and button was clicked again) -> toggle it off\n    placeWalls = false;\n    document.getElementById(buttonId).classList.remove(\"active\");\n  }\n}\n\n// Visualises an algorithm once all data is passed into it\n//\n// @param grids           Arr: an array of updated grids that each time have a new visited cell ticked\n// @param paths           Arr: an array of updated grids that each time have a new path cell highlighted\n// @param setGrid         Func: the function to set the grid\n//\n// @return null\nexport function visualiseAlgorithm(grids, paths, setGrid){\n  grids.forEach((grid, i) => {\n    setTimeout(() => {\n      setGrid(grid);\n    }, displayTimeout * i);\n  });\n\n  setTimeout(() => {\n    paths.forEach((path, i) => {\n      setTimeout(() => {\n        setGrid(path);\n      }, (displayTimeout * 2) * i);\n    });\n  }, displayTimeout * grids.length + 1);\n    \n}","import { useState, useEffect } from 'react';\nimport Header from './components/Header';\nimport { updateGrid, handleClick, handleNavClick } from './Helpers';\n\nconst CELL_SIZE = 30;\nconst ROWS = Math.floor((window.innerHeight * 0.8) / CELL_SIZE);\nconst COLS = Math.floor((window.innerWidth * 0.9) / CELL_SIZE);\n\nfunction App() {\n  const [grid, setGrid] = useState([]);\n  const [startCell, setStartCell] = useState([0, 0]);\n  const [endCell, setEndCell] = useState([ROWS-1, COLS-1]);\n  const [walls, setWalls] = useState([]);\n\n  // This will run every time start and end cells are updated\n  useEffect(() => {\n    setGrid(updateGrid(ROWS, COLS, startCell, endCell, walls));\n  }, [startCell, endCell, walls]);\n\n  return (\n    <div className=\"app\">\n      <Header onClick={handleNavClick} info={{grid: grid, setGrid: setGrid, startCell: startCell, endCell: endCell, setStartCell: setStartCell}} />\n      {/* Display the grid */}\n      <div className=\"grid\">\n        {grid.map((row, rowId) => {\n          return (\n            <div key={rowId} className=\"row\">\n              {row.map((cell, cellId) => {\n                return <div key={cellId} className={cell.startCell ? 'cell start' : cell.endCell ? 'cell end' : cell.wall ? 'cell wall' : cell.highlight ? 'cell highlight' : cell.visited ? 'cell visited' : 'cell'} onClick={() => handleClick(rowId, cellId, grid, setStartCell, setEndCell, {walls, setWalls})} />\n              })}\n            </div>\n          );\n        })}\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}